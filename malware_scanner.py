import argparse
import csv
import hashlib
import math
import os
import time
from pathlib import Path


SUSPICIOUS_EXTENSIONS = {
    ".exe",
    ".dll",
    ".scr",
    ".bat",
    ".cmd",
    ".ps1",
    ".js",
    ".vbs",
    ".jar",
    ".msi",
    ".lnk",
    ".hta",
}

SUSPICIOUS_PATTERNS = [
    b"powershell -enc",
    b"frombase64string(",
    b"wscript.shell",
    b"cmd.exe /c",
    b"invoke-webrequest",
    b"downloadstring(",
    b"reg add hkcu\\software\\microsoft\\windows\\currentversion\\run",
]

DEFAULT_MAX_FILE_MB = 2000
DEFAULT_MIN_SCORE = 2


def list_windows_drives() -> list[str]:
    drives = []
    for letter in "ABCDEFGHIJKLMNOPQRSTUVWXYZ":
        drive = f"{letter}:\\"
        if os.path.exists(drive):
            drives.append(drive)
    return drives


def choose_target_interactive() -> str:
    print("\nSelect scan target:")
    print("1) Enter folder path")
    print("2) Select drive letter")
    choice = input("Choice (1/2): ").strip()

    if choice == "1":
        return input("Enter full folder path: ").strip().strip('"')
    if choice == "2":
        drives = list_windows_drives()
        if not drives:
            raise RuntimeError("No drives found.")

        print("\nAvailable drives:")
        for index, drive in enumerate(drives, 1):
            print(f"{index}) {drive}")

        selected = int(input("Pick drive number: ").strip())
        return drives[selected - 1]

    raise ValueError("Invalid choice.")


def load_hash_iocs(ioc_file: str | None) -> set[str]:
    bad_hashes: set[str] = set()
    if not ioc_file:
        return bad_hashes

    ioc_path = Path(ioc_file)
    if not ioc_path.exists():
        print(f"[!] IOC file not found: {ioc_file}")
        return bad_hashes

    with ioc_path.open("r", encoding="utf-8", errors="ignore") as handle:
        for line in handle:
            text = line.strip().lower()
            if not text or text.startswith("#"):
                continue
            if len(text) == 64 and all(ch in "0123456789abcdef" for ch in text):
                bad_hashes.add(text)

    return bad_hashes


def shannon_entropy(data: bytes) -> float:
    if not data:
        return 0.0

    frequencies = [0] * 256
    for byte in data:
        frequencies[byte] += 1

    entropy = 0.0
    total = len(data)
    for count in frequencies:
        if count:
            probability = count / total
            entropy -= probability * math.log2(probability)
    return entropy


def sha256_file(path: str, chunk_size: int = 1024 * 1024) -> str:
    hasher = hashlib.sha256()
    with open(path, "rb") as handle:
        while True:
            chunk = handle.read(chunk_size)
            if not chunk:
                break
            hasher.update(chunk)
    return hasher.hexdigest()


def scan_file(path: str, bad_hashes: set[str], max_file_bytes: int) -> dict:
    result = {
        "path": path,
        "size": None,
        "sha256": "",
        "score": 0,
        "verdict": "clean",
        "reasons": [],
    }

    try:
        result["size"] = os.path.getsize(path)
    except Exception as error:
        result["reasons"].append(f"size_error:{error}")
        result["verdict"] = "error"
        return result

    extension = Path(path).suffix.lower()
    if extension in SUSPICIOUS_EXTENSIONS:
        result["score"] += 1
        result["reasons"].append(f"suspicious_extension:{extension}")

    if result["size"] <= max_file_bytes:
        try:
            file_hash = sha256_file(path)
            result["sha256"] = file_hash
            if file_hash in bad_hashes:
                result["score"] += 100
                result["reasons"].append("hash_match_ioc")

            with open(path, "rb") as handle:
                content = handle.read(min(result["size"], 1024 * 1024))
            lowered_content = content.lower()

            for signature in SUSPICIOUS_PATTERNS:
                if signature in lowered_content:
                    result["score"] += 2
                    readable_signature = signature.decode("utf-8", errors="ignore")
                    result["reasons"].append(f"pattern:{readable_signature}")

            if extension in {".exe", ".dll", ".scr", ".bin"}:
                entropy = shannon_entropy(content)
                if entropy >= 7.3:
                    result["score"] += 1
                    result["reasons"].append(f"high_entropy:{entropy:.2f}")

        except Exception as error:
            result["reasons"].append(f"scan_error:{error}")
            result["verdict"] = "error"
            return result
    else:
        result["reasons"].append(f"skipped_large_file>{max_file_bytes}B")

    return result


def scan_target(
    target_path: str,
    bad_hashes: set[str],
    max_file_bytes: int,
    min_score: int,
) -> tuple[list[dict], int, int, int, float, bool]:
    findings = []
    total_files = 0
    suspicious_count = 0
    error_count = 0
    interrupted = False
    start = time.time()
    last_progress_at = start
    progress_interval_seconds = 1.0

    try:
        for root, dirs, files in os.walk(target_path):
            dirs[:] = [
                folder
                for folder in dirs
                if folder.lower() not in {"$recycle.bin", "system volume information"}
            ]

            for file_name in files:
                total_files += 1
                full_path = os.path.join(root, file_name)
                result = scan_file(full_path, bad_hashes, max_file_bytes)

                if result["verdict"] == "error":
                    error_count += 1
                    findings.append(result)
                elif result["score"] >= min_score:
                    result["verdict"] = "suspicious"
                    suspicious_count += 1
                    findings.append(result)
                    print(f"\n[alert] score={result['score']} | {full_path}")

                now = time.time()
                if now - last_progress_at >= progress_interval_seconds:
                    elapsed = now - start
                    print(
                        (
                            "\r[progress] "
                            f"files={total_files} "
                            f"suspicious={suspicious_count} "
                            f"errors={error_count} "
                            f"elapsed={elapsed:.1f}s"
                        ),
                        end="",
                        flush=True,
                    )
                    last_progress_at = now
    except KeyboardInterrupt:
        interrupted = True
        print("\n\n[!] Stop requested. Finalizing partial report...")

    elapsed = time.time() - start
    print()
    return findings, total_files, suspicious_count, error_count, elapsed, interrupted


def save_report_csv(findings: list[dict], report_path: str) -> None:
    fields = ["verdict", "score", "path", "size", "sha256", "reasons"]
    with open(report_path, "w", newline="", encoding="utf-8") as handle:
        writer = csv.DictWriter(handle, fieldnames=fields)
        writer.writeheader()
        for finding in findings:
            row = finding.copy()
            row["reasons"] = "; ".join(row.get("reasons", []))
            writer.writerow(row)


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(
        description="Defensive malware scanner (heuristic + IOC hash match)."
    )
    parser.add_argument(
        "--path",
        help="Folder or drive path to scan, e.g. D:\\ or C:\\Users\\You\\Downloads",
    )
    parser.add_argument(
        "--interactive",
        action="store_true",
        help="Choose folder/drive interactively",
    )
    parser.add_argument(
        "--ioc-hashes",
        help="Path to text file with known malicious SHA256 hashes",
    )
    parser.add_argument(
        "--report",
        default="malware_scan_report.csv",
        help="CSV report output path",
    )
    parser.add_argument(
        "--max-file-mb",
        type=int,
        default=DEFAULT_MAX_FILE_MB,
        help="Max file size (MB) for content/hash scan",
    )
    parser.add_argument(
        "--min-score",
        type=int,
        default=DEFAULT_MIN_SCORE,
        help="Score threshold for suspicious verdict",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()

    target = choose_target_interactive() if args.interactive else args.path
    if not target:
        raise SystemExit("Provide --path or use --interactive")

    target = os.path.abspath(target)
    if not os.path.exists(target):
        raise SystemExit(f"Target does not exist: {target}")

    bad_hashes = load_hash_iocs(args.ioc_hashes)
    max_file_bytes = args.max_file_mb * 1024 * 1024

    print(f"[*] Scanning target: {target}")
    print(f"[*] Loaded IOC hashes: {len(bad_hashes)}")
    print(f"[*] Max file for deep scan: {args.max_file_mb} MB")
    print(f"[*] Suspicious threshold score: {args.min_score}")
    print("[*] Press Ctrl+C any time to stop and save a partial report.")

    findings, total_files, suspicious_count, error_count, elapsed, interrupted = scan_target(
        target_path=target,
        bad_hashes=bad_hashes,
        max_file_bytes=max_file_bytes,
        min_score=args.min_score,
    )

    save_report_csv(findings, args.report)

    print("\n=== Scan interrupted ===" if interrupted else "\n=== Scan complete ===")
    print(f"Total files visited : {total_files}")
    print(f"Suspicious findings : {suspicious_count}")
    print(f"Errors              : {error_count}")
    print(f"Elapsed             : {elapsed:.1f}s")
    print(f"Report              : {os.path.abspath(args.report)}")


if __name__ == "__main__":
    main()
